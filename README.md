# SNHU-projectsBG
//Full Stack Development I//

\\TRAVLR Project README\\
--Overview--
This project is a full-stack web application that serves both the customer and administrative sides of the application. It utilizes the MEAN stack (MongoDB, Express.js, Angular, and Node.js) for robust, full-stack development.
The customer-facing side offers users an intuitive interface for exploring and booking travel packages, while the admin side allows for efficient management of these packages and user data.

--Architecture--
Frontend Development
The frontend development includes the use of Express HTML, JavaScript, and a single-page application (SPA) built with Angular. Express HTML is used for rendering server-side pages, while the SPA provides a dynamic and responsive user experience, allowing users to navigate between different sections of the application without page refreshes.

--Backend Development--
The backend development uses Node.js and Express.js for server-side scripting. A NoSQL MongoDB database is used for data storage due to its flexibility and scalability.

--Functionality--
JSON vs JavaScript
JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write, while JavaScript is a programming language used to create interactive effects within web browsers. JSON ties together the frontend and backend development pieces by providing a standardized way to represent and exchange data between the two.

--Refactoring and Reusable UI Components--
During the full-stack process, code was refactored to improve functionality and efficiencies. For example, reusable UI components were created to reduce code duplication and improve maintainability. The benefits of reusable UI components include improved consistency, reduced development time, and easier debugging.

--Testing--
API Testing
Methods for request and retrieval necessitate various types of API testing of endpoints. This includes unit testing, integration testing, and end-to-end testing to ensure that the API functions as expected.

--Security--
Security is an important aspect of a full-stack application. It involves securing endpoints, implementing authentication and authorization mechanisms, and ensuring data privacy.

--Reflection--
This course has helped me reach my professional goals by providing me with a solid foundation in full-stack development. I have learned and developed skills in frontend and backend development, database management, and testing. These skills make me a more marketable candidate in my career field, as they are in high demand in the industry.


//Current/Emerging Trends in CS//

\\Reflection\\
For the pirate intelligent agent project, I was given a partially complete reinforcement learning model that utilized a Q-learning algorithm to train an agent to navigate through a maze and reach a goal. The code I was given included the basic structure of the maze, the game environment, and some of the Q-learning algorithm implementation. My contributions to the project involved completing the Q-learning algorithm implementation, tuning hyperparameters, and testing the model to ensure its effectiveness.

Throughout this course, I've learned that computer scientists play a crucial role in advancing technology and solving complex problems in various domains. They develop algorithms, design systems, and create software to automate tasks, analyze data, and solve real-world problems. As a computer scientist, my approach to solving problems involves breaking down complex tasks into smaller, more manageable components, designing algorithms and data structures to solve those components, and implementing those solutions using programming languages and tools.

In addition to technical skills, computer scientists have ethical responsibilities to consider. We must ensure that our work does not harm others or violate ethical principles. This includes considering the privacy and security of user data, ensuring fairness and transparency in algorithmic decision-making, and adhering to ethical guidelines and professional standards. Ultimately, the goal of computer science is to use technology to improve people's lives, and this requires us to prioritize ethical considerations in our work.

//Comp Graphic & Visualization//

\\Reflection\\
Designing Software
Approach: My approach to designing software begins with understanding the problem, sketching out initial ideas, and then iteratively refining them. In this project, I started by analyzing the 2D image and envisioning how each object could be translated into 3D space.
New Design Skills: This project helped me craft skills in spatial thinking and 3D modeling. I learned to deconstruct complex objects into simpler geometric forms, an essential skill in 3D design.
Design Process: My design process involved initial sketches, selecting appropriate primitive shapes for each object, and then detailing them with textures and lighting. This methodical process was key in translating a 2D image into a 3D scene.
Future Application: The tactics from this design approach, especially breaking down complex objects into basic shapes, can be applied in future work like game design, architectural visualization, and VR/AR development.
Developing Programs
Approach: My development approach is iterative and test-driven. I start with a basic implementation and gradually add complexity while constantly testing for functionality and visual accuracy.
New Development Strategies: In developing the 3D scene, I used OpenGL for the first time, which broadened my understanding of graphical programming and 3D rendering.
Iteration in Development: Iteration was crucial. Each object in the scene went through multiple iterations, from basic shapes to detailed, textured models. This approach ensured accuracy and quality in the final output.
Evolution of Code Development: My code development evolved to be more modular and reusable. Functions like GenerateCylinder were developed to create objects with varying parameters, demonstrating an evolution from hard-coded models to more dynamic, flexible coding.
Computer Science and Personal Goals
Relevance to Goals: Computer science, especially computational graphics and visualization, is instrumental in reaching my goals in fields like game development, animation, and interactive media design.
Educational Pathway: Through this project, I've gained invaluable skills in 3D modeling, lighting, and texturing, which are directly applicable in my educational pursuits in computer graphics and game design.
Professional Pathway: The knowledge of computational graphics will be highly beneficial in my professional journey, especially in roles that involve creating visual content for media, advertising, or software development. The understanding of how to create realistic 3D scenes is a skill in high demand in many tech-driven industries.

//Client-Server Development//

\\Journal\\
1. How do you write programs that are maintainable, readable, and adaptable? 
Writing maintainable, readable, and adaptable programs involves following best practices, such as modularizing code and adhering to a clean code style. In Project One, the CRUD Python module was designed to handle database operations, providing a clear separation of concerns. This modular approach facilitated easy integration with the dashboard in Project Two. The advantages included code reusability, easier debugging, and scalability. In the future, this CRUD module could be extended for additional database interactions in different projects, promoting consistency and reducing development time.

2. How do you approach a problem as a computer scientist? 
As a computer scientist, approaching a problem involves understanding requirements, breaking down tasks, and utilizing appropriate tools. For Grazioso Salvare, I began by comprehending the needs and translating them into database and dashboard specifications. This project differed from others by involving a full-stack approach, integrating MongoDB and Dash. In the future, I would employ similar strategies, emphasizing a systematic problem-solving approach, understanding client needs, and choosing technologies tailored to the project's requirements.

3. What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?
Computer scientists design, implement, and optimize software solutions to address real-world challenges. In the context of Grazioso Salvare, my work contributes by providing an efficient and user-friendly dashboard to streamline their dog identification and training processes. The project enhances data accessibility, allowing them to make informed decisions about search-and-rescue dog candidates. The application of technology in this manner can significantly improve Grazioso Salvare's operations, making their workflow more efficient and aiding in the identification of suitable dogs for training.
//Software Security//

\\Journal\\
1. Briefly summarize your client, Artemis Financial, and their software requirements. Who was the client? What issue did they want you to address?
Artemis Financial, a financial consulting company, was our client, and they sought to modernize their operations while increasing the security of their public web application. They offered financial planning services encompassing savings, retirement, investments, and insurance, which necessitated highly secure software. The primary concern was implementing encryption, especially the Advanced Encryption Standard (AES) for data protection. The client needed security layers to safeguard sensitive financial data.

2. What did you do very well when you found your client’s software security vulnerabilities? Why is it important to code securely? What value does software security add to a company’s overall wellbeing?
We conducted a thorough vulnerability assessment, identifying and addressing vulnerabilities methodically. This diligence ensured that security flaws were not merely patched but fundamentally addressed. Coding securely is essential because it guards against data breaches, financial losses, and reputational damage. Software security enhances a company's overall wellbeing by safeguarding its assets, maintaining customer trust, and ensuring compliance with regulations.

3. What part of the vulnerability assessment was challenging or helpful to you?
One challenging aspect of the vulnerability assessment was reconciling the need for tight security without compromising system functionality. Striking a balance between robust security measures and a user-friendly experience was pivotal. It helped us appreciate the delicate trade-offs in software security.

4. How did you increase layers of security? In the future, what would you use to assess vulnerabilities and decide which mitigation techniques to use?
We increased security layers by implementing robust encryption using AES, secure hash functions (SHA-256), and ensuring the proper use of asymmetric cryptography for signing. In the future, we would employ tools like penetration testing and code analysis to assess vulnerabilities comprehensively. Deciding on mitigation techniques would involve evaluating risks and matching them with appropriate countermeasures, considering factors like severity and potential impact.

5. How did you make certain the code and software application were functional and secure? After refactoring the code, how did you check to see whether you introduced new vulnerabilities?
We conducted thorough testing to ensure both functionality and security. The process included unit testing, integration testing, and security testing. After refactoring the code, we employed regression testing to verify that new vulnerabilities were not introduced. This included running security scans and monitoring the application for any unusual activities.

6. What resources, tools, or coding practices did you use that might be helpful in future assignments or tasks?
In this assignment, we utilized various resources like security libraries, cryptographic best practices, and industry standards. We also employed development and testing tools such as code analyzers, testing frameworks, and security scanning tools. These resources, combined with a deep understanding of secure coding practices, will be invaluable in future assignments and real-world tasks.

7. Employers sometimes ask for examples of work that you have successfully completed to show your skills, knowledge, and experience. What might you show future employers from this assignment?
From this assignment, I can showcase my ability to perform a comprehensive vulnerability assessment and implement security enhancements. I can demonstrate my proficiency in cryptographic techniques, secure coding practices, and my understanding of industry standards. Additionally, I can highlight my skill in conducting secure code refactoring while ensuring the software remains functional and free from new vulnerabilities. This assignment is a strong example of my software security expertise, which can be valuable for future employers seeking robust security practices.

//Software Test Automation & QA//

\\Reflection\\
1. How can I ensure that my code, program, or software is functional and secure?

Testing: Comprehensive testing is key. Employ various testing types, such as unit testing, integration testing, and end-to-end testing. This will help you identify and rectify bugs, ensuring your software functions as intended.
Security Scanning: Regularly scan your code and applications for security vulnerabilities. Utilize security tools and follow best practices for secure coding, such as input validation and access control.
Code Reviews: Collaborate with peers for code reviews. Fresh perspectives often uncover issues that might be overlooked by the original developer.
Documentation: Properly document your code and software. This not only aids in understanding but also helps in maintaining security through clear code architecture.
Security Principles: Apply security principles like the Principle of Least Privilege and Defense in Depth to ensure your software is resilient to attacks.
Security Updates: Stay updated with security patches and updates for libraries and dependencies. Timely updates can patch known vulnerabilities.

2. How do I interpret user needs and incorporate them into a program?
User Research: Begin with user research. Engage with end-users, stakeholders, or use surveys and interviews to understand their requirements and expectations.
User Stories: Create user stories to capture user needs and functionalities from their perspective. These should be clear, concise, and specific.
Prioritization: Prioritize user needs based on their importance and impact. Use techniques like MoSCoW (Must-haves, Should-haves, Could-haves, and Won't-haves) to prioritize features.
Prototyping: Develop prototypes or mockups to visualize the user interface and gather feedback early in the process.
User Acceptance Testing (UAT): Involve users in UAT to ensure that the program aligns with their needs. Their feedback is invaluable for refining the software.
Iterative Development: Embrace an iterative development process, where you continuously gather feedback and make improvements based on user input.
Clear Communication: Maintain open lines of communication with users and stakeholders throughout the development process to address changing needs and expectations.
Incorporating user needs is an ongoing process. User needs can evolve, so it's vital to stay engaged with users and adapt to their changing requirements.

3. How do I approach designing software?
Requirements Analysis: Start by understanding the requirements thoroughly. Engage with stakeholders, users, and consider non-functional requirements.
System Architecture: Design the overall system architecture. Decide on the system's components, their interactions, and data flow.
Modular Design: Break down the software into smaller, manageable modules or components. Each module should have a specific function and interface with other modules.
Data Design: Plan how data will be stored, accessed, and processed. This includes designing databases and data structures.
User Interface (UI) Design: Create a user-friendly interface that aligns with user needs and provides an intuitive user experience.
Coding Standards: Establish coding standards and guidelines to maintain consistency and quality in the codebase.
Testing Strategy: Develop a comprehensive testing strategy, including unit testing, integration testing, and end-to-end testing to ensure the software functions correctly.
Documentation: Document the software design, code, and user manuals comprehensively. This helps with future maintenance and onboarding.
Version Control: Utilize version control systems (e.g., Git) to track changes and collaborate effectively with a team.
Iterative Approach: Design is not a one-time activity. Embrace an iterative approach, where you refine the design based on feedback and changing requirements.

//Analysis and Design//

\\Journal\\
1. What was the problem you were solving in the projects for this course?
    The goal was to create a program that can load course data from a file, store it in a suitable data structure, and provide various functionalities like listing all courses, displaying specific course         
    information, and handling prerequisites.
2. How did you approach the problem? Consider why data structures are important to understand.
    The approach involved reading data from a file, parsing it into meaningful course objects, and storing these objects in a data structure. The program then offered different operations on this data, such as   
    displaying course lists and information. Understanding data structures is crucial for solving such problems because they provide a way to efficiently organize and access data, which directly impacts the 
    performance and usability of the program. The choice of data structure can significantly affect the efficiency of various operations like insertion, retrieval, and searching.
3.How did you overcome any roadblocks you encountered while going through the activities or project?
    Through careful testing, debugging and some help from drop-in tutoring I was able to overcome all roadblocks that I ran into.
4. How has your work on this project expanded your approach to designing software and developing programs?
    Working on this project expanded my approach to designing software by emphasizing the importance of data structure selection based on the requirements of the problem. It highlighted the trade-offs between 
    different data structures and how they impact performance. Additionally, I gained experience in designing user-friendly interfaces, handling user input, and managing program flow.
5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
    This project helped me develop skills in writing maintainable, readable, and adaptable programs. The code in project two demonstrates good practices such as using meaningful variable and function names, 
    modularizing code into functions, and providing comments for clarity. These practices enhance code readability and maintainability. Additionally, the program's structure allows for easy adaptation to future 
    changes or enhancements, showcasing the flexibility of my design.

//Operating Platforms//

\\The Gaming Room reflection\\
1. Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design? What did you do particularly well in developing this documentation?

The client was The Gaming Room. They currently had a game called Draw It or Lost It for Android. The Gaming Room wanted to improve the software functionality and to expand to other platforms. I kept this document clear, concise, and to the point.

2. What did you do particularly well in developing this documentation?

My description of the domain model and the server/client side descriptions for different operating platforms was well desinged and written.

3. What about the process of working through a design document did you find helpful when developing the code?

It helps to keep you focused on the task at hand and to decide on what tasks are important and which ones don't need time and focus on.

4. If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

Recomendations were hard for me, I haven't had a ton of experience in programming before beginning my computer science degree. After I have had more in field experience, I would revise my recommendations based off what I have been successful with.

5. How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

I took what was needed for the functionallity of the game and then split it up so that there would be less work and time spent expanding to other operating platforms. All while still keeping the game the same. Your client may be the one to ask you to do the work, but it's the users who truely control the product. If they don't trust the software or have problems with it, then they won't use it.

6. How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?

I put my focus on clear documentation and game functionality to allow easier updates and maintenence. I believe that in the future I will be part of a team, so I would take my experiences and those of my peers, and find the best solution to complete the project.

//Programming Languages//

\\Corner Grocer App Reflection\\

1. Summarize the project and what problem it was solving.
  This project was for a grocery store to see what items their customers purchased the most. It took an input file and read items to see how many times each item appeared. It then outputted the item name and frequency using menu options for the user to choose from that allowed them to either pick an item and see it's frequency, print the full list of items with their numerical frequency, print the list in histogram form and an option to exit the menu. This also output a text file with item names and their frequency.
  
2. What did you do particularly well?
My code utilized classes and functions very well so that the only code in my main function was to call the other functions.

3. Where could you enhance your code? How would these improvements make your code more efficient, secure, and so on?
I could maybe make the classes in different header files so that if I needed to grow the program I could just include those header files and inherit from the function classes to create new specific functions like lableling the items into seperate categories so that the user could see the frequency of fruits or vegetables etc. 

4. Which pieces of the code did you find most challenging to write, and how did you overcome this? What tools or resources are you adding to your support network?
The map function was new to me and I had to flip back through the zybooks lecture on the matter and I referenced some examples in stackoverflow.

5. What skills from this project will be particularly transferable to other projects or course work?
Many programming languages are similar, so the skills from this project could help with java or python projects as well

6. How did you make this program maintainable, readable, and adaptable?
I used switch cases instead of if-else statements for my menu functions for a cleaner code appearance and faster functionality. It would also be easier to make changes the menu this way. I added in-line comments to help with understanding the funciton of my code.


//Software Development Lifecycle//

1. How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?

  I receive customer feedback for features that are wanted and create user stories that reflect the customer's needs. I develop user stories with specific requirements so that a tester can build cases that will implement the features into a program. These stories are labeled with their priority and what actions the user will take to get results. Once the stories are laid out and a tester creates test cases, the developer can implement the features into the program. Once the code is implemented the tester can refer to the cases and user stories to see if they meet the requirements.

2. How do I approach developing programs? What agile processes do I hope to incorporate into my future development work?

  I approach development with the user stories and test cases in mind so that I know what features to implement and in what order. I can use agile planning to setup a board with what stories I will implement during each sprint along with practices like poker-planning to decide value and order of stories to implement. I can use agile methodology when changes are made to the product backlog and adapt the program as needed. I would use the daily scrum meetings to communicate what I did the day before, what I will do next, and what impediments I have run into.
  
3. What does it mean to be a good team member in software development?

  -Be respectful of others
  -Commit to the project
  -Accept responsibility and be accountable
  -Work collaboratively and make decisions with the team
  -Recognize and celebrate individual and team accomplishments
  -Provide feedback in a constructive manner and don't take offense to constructive feedback
  -Abide by the agile manifesto values
  -Be on time and productive
